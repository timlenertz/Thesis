using namespace Eigen;

pose ps1 = pose::from_string("0.0111054,-5.34705,3.16065,0.888177,0.459471,0.00140555,0.00514437");
pose ps2 = pose::from_string("1.19905,5.00239,3.73934,0.0271785,0.0955291,0.430536,0.897092");
pose vps = pose::from_string("-3.91371,0.746101,4.11871,0.631202,0.178814,-0.261022,-0.70815");

range_image_camera cam1(ps1, angle::degrees(60), angle::degrees(60), 600, 600);
range_image_camera cam2(ps2, angle::degrees(60), angle::degrees(60), 600, 600);

auto og = make_relief_point_cloud(5.0, 100000);
og.set_point_indices();

auto fx = project(og, cam1);
auto lo = project(og, cam2);
set_unique_color(lo.begin(), lo.end(), rgb_color::red);
set_unique_color(fx.begin(), fx.end(), rgb_color::blue);

lo.random_displacement(0.2);

viewer_window vw;
vw->add(fx, lo);
vw.select_object(lo);
vw->camera().set_relative_pose(vps);

auto weight_func = [&](const point_full& fx_p, const point_full& lo_p) -> float {
	const point_full& fx_real_p = *(og.begin() + fx_p.get_index());
	const point_full& lo_real_p = *(og.begin() + lo_p.get_index());
	float d = distance(fx_real_p, lo_real_p);
		
	const float max_d = 0.2;
	if(d > max_d) return 0.0;
	else return (d/max_d);
};

kdtree_point_cloud_full fxt = fx;

auto reg = make_iterative_closest_point_registration(fxt, lo, accept_point_filter(), weight_func);
reg.run_live(fxt, lo);



reg.compute_estimated_transformation_and_error();
space_registration_correspondences_list lst;
lst.set_parent(fx);
reg.correspondences(*lst);
vw->add(lst);

