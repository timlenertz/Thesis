using namespace Eigen;

pose ps1 = pose::from_string("0.0111054,-5.34705,3.16065,0.888177,0.459471,0.00140555,0.00514437");
pose ps2 = pose::from_string("1.19905,5.00239,3.73934,0.0271785,0.0955291,0.430536,0.897092");
pose vps = pose::from_string("-3.91371,0.746101,4.11871,0.631202,0.178814,-0.261022,-0.70815");

range_image_camera cam1(ps1, angle::degrees(60), angle::degrees(60), 600, 600);
range_image_camera cam2(ps2, angle::degrees(60), angle::degrees(60), 600, 600);

auto og = make_relief_point_cloud(5.0, 100000);
og.set_point_indices();

auto fx = project(og, cam1);
auto lo = project(og, cam2);
set_unique_color(lo.begin(), lo.end(), rgb_color::red);
set_unique_color(fx.begin(), fx.end(), rgb_color::blue);

compute_normal_direction_weights(fx.begin(), fx.end(), fx.transformation_from(lo)*ps2.position, angle::degrees(150.0));
colorize_by_weight(fx.begin(), fx.end(), 0.0, 1.0, rgb_color::blue, rgb_color::yellow);

lo.random_displacement(0.2, angle::degrees(2.0));

viewer_window vw;
auto& sfx = vw->add(fx);
auto& slo = vw->add(lo);
sfx.point_size = 10;
vw.select_object(lo);
vw->camera().set_relative_pose(vps);


auto weight_func = [&](const point_full& fx_p, const point_full& lo_p) -> float {
	float nc = fx_p.get_normal().dot( lo_p.get_normal() );
	if(nc < 0.7) return 0.0;
		
	float d = distance(fx_p, lo_p);
	if(d > 0.1) return 0.0;

	const point_full& fx_real_p = *(og.begin() + fx_p.get_index());
	const point_full& lo_real_p = *(og.begin() + lo_p.get_index());
	float rd = distance(fx_real_p, lo_real_p);
		
	const float max_rd = 1.0;
	if(rd > max_rd) return 0.0;
	else return (rd/max_rd)*(rd/max_rd)*(rd/max_rd);
};

kdtree_point_cloud_full fxt = fx;

space_registration_correspondences_list lst;
lst.set_parent(fxt);
vw->add(lst);

auto reg = make_iterative_closest_point_registration(fxt, lo, accept_point_filter(), weight_func);

auto reg_step = [&]() {
	reg.apply_loose_transformation(fxt, lo);

	reg.step();
	lst->clear();
	reg.correspondences(*lst, reg.accumulated_transformation());
	lst.handle_update();

	std::cout << "Error: " << reg.current_error() << std::endl;
};

